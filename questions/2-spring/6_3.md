# HTTP 요청이 들어왔을 때 요청을 받고 응답하기 까지의 전 과정을 설명해주세요.
### 작성자: [@KoSeonJe](https://github.com/KoSeonJe)
### 필수 키워드
  - DispatcherServlet
  - Filter
  - Intercepter
  - Resolver
  - Converter

## 1. DispatcherServlet

- HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 Front Controller이다.
    - Front Controller : 웹 어플리케이션에서 주로 사용되는 디자인 패턴으로 컨트롤러에서 중복으로 처리해야 하는 사항을 공통 기능을 한 곳에서 관리하는 입구 역할을 하는 컨트롤러의 개념
- 클라이언트로부터 요청이 오면 Tomcat과 같은 서블릿 컨테이너가 요청을 받는다. 이 모든 요청을 Front Controller인 DispatcherServlet이 가장 먼저 받고, 공통적인 작업을 처리한 후 해당 요청을 처리해야 하는 컨트롤러를 찾아 작업을 위임한다.

### 정적 자원 처리

- DispatcherServlet이 모든 요청을 처리할 수 없으므로,  정적 자원 요청을 분리해야 한다.
- Dispatcher Servlet이 요청을 처리할 컨트롤러를 먼저 찾고, 요청에 대한 컨트롤러를 찾을 수 없는 경우에, 2차적으로 설정된 자원(Resource)경로를 탐색하여 자원을 탐색하는 것이다.

### 동작 과정

<img width="929" alt="스크린샷 2023-08-26 오후 9 32 12" src="https://github.com/COW-edu/backend-cs-study/assets/127813439/d50f0c8d-ed14-4639-a7ce-05a27f638080">
### 1. 클라이언트의 요청을 Dispatcher Servlet이 받는다.

- Web Context에서 Filter들을 지나 Spring Context에서 Dispatcher Servlet이 가장 먼저 요청을 받는다.

### 2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음.

- 요청을 처리할 핸들러(컨트롤러)를 찾고 해당 객체의 메소드를 호출한다.
- 따라서 가장 먼저 어느 컨트롤러가 요청을 처리할 수 있는지를 식별해야 하는데, 해당 역할을 하는 것이 바로 HandlerMapping이다.
- 최근에는 ‘@Controller’에 ‘@RequestMapping’관련 어노테이션을 사용해 컨트롤러를 작성하는 것이 일반적이다.
- 이 ‘@Controller’ 방식은 RequestMappingHandlerMapping가 처리한다.
- 이는 ‘@Controller’로 작성된 모든 컨트롤러를 찾고 파싱하여 HashMap으로 <요청 정보, 처리할 대상> 관리한다.
- 요청이 오면 (Http Method, URI) 등을 사용해 요청 정보를 만들고, HashMap에서 요청을 처리할 대상(HandlerMethod)를 찾은 후에 HandlerExecutionChain으로 감싸서 반환한다
- HandlerExecutionChain으로 감싸는 이유는 컨트롤러로 요청을 넘겨주기 전에 처리해야 하는 **인터셉터** 등을 포함하기 위해서이다.

### 3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함

- Dispatcher Servlet은 컨트롤러로 직접 위임하는 것이 아닌 HandlerAdapter를 통해 위임한다.
- 그 이유는 컨트롤러의 구현 방식이 다양하기 때문이다.
- Controller 인터페이스로 구현했던 과거와 달리 최근 어노테이션 기반 프로그래밍을 추구하기 때문에 컨트롤러가 다양하게 작성된다.
- 그에 대응하기 위해 HandlerAdapter라는 어댑터 패턴을 적용함으로써 컨트롤러의 구현 방식에 상관없이 요청을 위임할 수 있도록 하였다.

### 4. 핸들러 어댑터가 컨트롤러로 요청을 위임함.

- 컨트롤러로 위임하기 전/후에 공통적인 전/후처리 과정이 필요하다.
- 대표적으로 인터셉터들을 포함해 요청 시에 ‘@RequestParam’, ‘@RequestBody’ 등을 처리하기 위한 ArgumentResolver 처리
- ResponseEntity의 Body를 Json으로 직렬화하는 등의 처리를 하는 ReturnValueHandler 처리
- ArgumentResolver 등을 통해 파라미터가 준비 되면 리플렉션을 이용해 컨트롤러로 요청을 위임한다.
    - 리플렉션 :  구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

### 5. 비즈니스 로직을 처리한다.

- 이후에 컨트롤러는 서비스를 호출하고 우리가 작성한 비즈니스 로직들이 진행된다.

### 6. 컨트롤러가 반환값을 반환한다.

- 주로 ResponseEntity를 반환한다.
    - ResponseEntity : HTTP 요청(Request) 또는 응답(Response)에 해당하는 HttpHeader와 HttpBody를 포함하는 클래스인 HttpEntity를 구현한 클래스


### 7. 핸들러 어댑터가 반환값을 처리한다.

- 컨트롤러로부터 받은 응답을 응답 처리기인 ReturnValueHandler가 후처리한 후에 Dispatcher Servlet으로 돌려준다
- 컨트롤러가 ResponseEntity를 반환하면 HttpEntityMethodProcessor가 **MessageConverter**를 사용해 응답 객체를 직렬화하고 응답 상태(HttpStatus)를 설정한다.
- 컨트롤러가 View 이름을 반환하면 ViewResolver를 통해 View를 반환한다.

### 8. 서버의 응답을 클라이언트로 반환한다.

- Dispatcher Servlet을 통해 반환되는 응답은 다시 Filter들을 거쳐 클라이언트에게 반환된다.
- 응답이 화면이라면 View를 찾아서 반환해주는 ViewResolver가 적절한 화면을 내려준다.

## 2. Filter

<img width="926" alt="스크린샷 2023-08-26 오후 9 34 57" src="https://github.com/COW-edu/backend-cs-study/assets/127813439/82b2d7b9-cd0f-4e83-9502-ada2502b604e">
### Filter란?

- Dispatcher Servlet에 요청이 전달되기 전/후에 url패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공한다.
- 주로 요청에 대한 인증, 권한 체크 등을 하는데 사용된다. 예를 들어 요청이 DispatcherServlet에 전달되기 전에 헤더를 검사해 인증 토큰이 있는지 없는지, 올바른지 아닌지 등을 검사할 수 있다.
- 필터를 만들면 필터를 Spring Bean으로 등록해야 한다.
- 웹 컨텍스트에서 동작

### Filter 메소드

- init() : 필터가 생성될 때 수행되는 메소드, 필터 객체를 초기화 및 서비스에 추가
- doFilter() : Request, Response가 필터를 거칠 때 수행되는 메소드
- destroy() : 필터가 소멸될 때 수행되는 메소드, 필터 객체를 제거

## 3. Interceptor

- 인터셉터는 DispatcherServlet과 컨트롤러 사이에서 요청을 가로채는 역할을 수행한다.
- controller의 핸들러(클라이언트가 요청한 url에 따라 실행되는 메서드)를 호출하기 전과 후에 요청과 응답을 가로채서 원하는 동작을 추가할 수 있도록 해준다
- (ex. 로그인 체크, 응답에서 알림 개수 조회)
- 스프링 컨텍스트에서 동작
- HandlerMapping에서 반환한 HandlerExecutionChain은 1개 이상의 인터셉터가 등록되어 있다면 순차적으로 인터셉터들을 거쳐 컨트롤러가 실행되도록 하고, 인터셉터가 없다면 바로 컨트롤러를 실행한다

### Interceptor 메소드

- preHandle 메소드
    - 컨트롤러가 호출되기 전에 실행된다.
    - 컨트롤러 이전에 처리해야하는 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용
    - 반환 타입은 boolean이다. true면 다음 작업 실행, false면 중단
- PostHandle 메소드
    - 컨트롤러가 호출된 후 실행
    - 컨트롤러 이후 후처리 작업이 필요할 때 사용
    - RestAPI기반 컨트롤러(‘@RestController’)를 만들면서 자주 사용되지 않음
    - 중간에 예외가 발생하면 호출되지 않는다.
- afterCompletion 메소드
    - 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다.
    - 중간에 예외가 발생하더라도 반드시 호출된다.

[Reference]

- https://mangkyu.tistory.com/18#recentComments
- https://mangkyu.tistory.com/173