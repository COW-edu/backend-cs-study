# Java Collections - TreeSet, LinkedList

# Java / TreeSet

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/f5dd285f-3e82-466c-85b2-55549ec87027)


## 트리에 대한 개념

- 트리는 대표적인 **비선형 구조(Non Linear)**를 가진 자료구조입니다.

### 비선형 구조**(Non Linear)**

- 데이터를 저장하기 위한 방법으로 데이터 간의 관계를 이루면서 **계층적인 구조**를 가지며 **일렬로 나열되지 않은 자료구조** 형태를 의미합니다.

### 계층적인 구조

- **데이터 요소들이 상위와 하위 간의 관계를 가지며, 부모와 자식으로 구성되는 구조를 의미합니다.**
- 이러한 구조에서는 상위 요소가 하위 요소를 포함하고 있으며, 하위 요소는 상위 요소에 속하는 관계를 가지고 있습니다.
- 계층적 구조에서는 각 요소들이 단계적으로 조직되어 있고, 상위 요소에 의해 하위 요소들이 제어될 수 있습니다.

## TreeSet이란?

- 자바 TreeSet은 **Set 인터페이스를 구현한 클래스**입니다.
- 자바 TreeSet은 HashSet과 마찬가지로 **중복 데이터를 저장하지 않고 저장 순서를 유지하지 않습니다**.
- 하지만 TreeSet은 HashSet과 달리 **이진 탐색 트리(BinarySearchTree) 구조**로 이루어져 있습니다.
- 따라서 데이터의 추가와 삭제는 HashSet보다 시간이 더 걸리지만 **검색과 정렬에 유리하다는 특징이 있습니다**.

## TreeSet 구현

- TreeSet은 레드-블랙 트리로 구현되어있습니다.
- 보통 이진 탐색 트리는 **트리의 높이만큼 시간**이 걸립니다.
- 데이터의 값이 트리에 잘 분산되어 있다면 효율성에 큰 문제가 없으나 데이터가 들어올 때 값이 편향되게 들어올 경우 한 쪽으로 크게 치우쳐진 트리가 되어 굉장히 비효율적인 퍼포먼스를 냅니다.
- 레드-블랙 트리는 일정한 실행 시간을 보장하는 자체 균형 이진 트리입니다.
- 레드 블랙 트리는 상위 노드보다 작은 값을 가지는 노드는 왼쪽 하위로, 큰 값을 가지는 노드는 오른쪽 하위로 배치하여 데이터의 추가나 삭제 시 트리가 한쪽으로 치우쳐지지 않도록 균형을 맞춥니다.

### Red-Black Tree

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/944bb4d8-9fa0-46bf-9ce0-e9d9bfa337ce)


**RB Tree의 다섯 가지 규칙**

1. 모든 노드는 **빨간색** 혹은 **검은색** 노드이다.

2. 루트 노드는 **검은색**이다.

3. 모든 리프 노드들은 **검은색** 이다.

4. **빨간색** 노드의 자식은 **검은색**이다.

5. 루트 노드에서 리프 노드까지 거쳐가는 **검은 노드의 개수**가 모든 리프 노드에 대해서 같아야한다.

# Java / Linked List

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/93620dc1-3172-43b1-a6f8-3c547ce0892a)


## 선형 구조(Linear Structure)

- 데이터를 저장하기 위한 기본적인 형태로 데이터가 **일렬로 나열**되어 있을 뿐만 아니라 **데이터 간에 순서가 있고 논리적으로 이어져 있는 구조**를 의미합니다.

## **연결 리스트(Linked List)란?**

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/f491a223-196f-4862-8fc6-d27711237c10)


- **데이터 요소가 노드(Node)로 구성된 선형 자료구조입니다.**
- **각 노드는 데이터와 다음 노드를 가리키는 링크(포인터)로 이루어져 있습니다.**
- 연결 리스트는 동적 크기 조정이 용이하고, 삽입과 삭제가 빠르게 이루어질 수 있는 장점이 있습니다.
- 하지만 특정 위치에 접근하는 데에는 선형적인 탐색이 필요하기 때문에 접근 속도가 느릴 수 있습니다.
- 주로 데이터의 삽입과 삭제가 빈번하게 일어나는 상황에서 주로 사용됩니다.
- 큐(Queue)나 스택(Stack)과 같은 자료구조를 구현할 때 많이 활용됩니다. 또한 데이터 크기가 동적으로 변환하는 상황에서 유용하게 사용됩니다.

### **LinkedList는 조회 속도가 느린 이유**

- LinkedList는 목표 노드를 조회하기 위해서는 각 노드가 가리키는 포인터를 가지고 따라가야합니다.
- 즉, 목표로 하는 노드까지 연결 리스트 길이에 비례하여 시간이 걸리므로 접근 시간이 길어지는 것입니다.

## LinkedList 종류

- **단순 연결 리스트(Singly Linked List)**
- **이중 연결 리스트(Double Linked List)**
- **순환 연결 리스트(Circular Linked List)**

### **단순 연결 리스트(Singly Linked List)**

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/9cbda4de-62a4-4d12-bac0-33fe46c93423)


- 데이터 요소인 노드들이 **링크**로 연결되어 있는 자료구조입니다. 각 노드는 데이터와 다음 노드를 가리키는 링크로 이루어져 있습니다.
- 데이터의 검색에는 선형적인 탐색이 필요하므로 효율성이 떨어질 수 있습니다. 특정 위치의 요소에 접근하기 위해서는 **헤드부터 순차적으로 탐색 해야 한다는 단점**이 있습니다.
- 스택(Stack)이나 큐(Queue)와 같은 다른 추상 자료형을 구현하는 데에도 활용

### **이중 연결 리스트(Double Linked List)**

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/ff4f9490-cf03-42c8-b685-28bef02e43e2)


- **각 노드가 이전 노드와 다음 노드를 모두 가리키는 링크로 이루어져 있는 자료구조입니다.**
- **양방향으로 탐색이 가능하며, 어떤 위치의 노드에서도 앞과 뒤의 노드에 접근할 수 있습니다.**
- 이중 연결 리스트는 단순 연결 리스트와 달리 양방향으로 순회할 수 있으며, 양쪽 방향에서의 삽입과 삭제가 가능합니다.
- 이는 데이터의 검색과 수정을 효율적으로 처리할 수 있는 장점을 제공합니다.
- 그러나 각 노드가 이전 노드와 다음 노드를 가리키는 링크를 유지해야 하므로, 메모리 사용량이 증가하게 됩니다.
- LRU Cache와 같은 자료구조에서 활용

### **순환 연결 리스트(Circular Linked List)**

![image](https://github.com/Hoya324/backend-cs-study/assets/96857599/58979f4e-8481-4604-a757-c50c4df8ae9e)


- **마지막 노드가 첫 번째 노드를 가리키는 형태로 이루어져 있는 자료구조입니다.**
- 순환 연결 리스트는 데이터의 삽입과 삭제를 빠르게 처리할 수 있는 장점이 있습니다.
- 순환 연결 리스트는 **리스트의 순서를 계속해서 이동하면서 작업을 수행해야 하는 경우에 유용**합니다.
    - 예를 들어, 원형 큐(Circular Queue)나 원형 버퍼(Circular Buffer)와 같이 순환적인 동작이 필요한 자료 구조에서 사용

## Reference

- https://adjh54.tistory.com/320
- https://adjh54.tistory.com/319
- https://seasome1.com/%EC%9E%90%EB%B0%94-treeset/
- https://codable.tistory.com/16
- https://adjh54.tistory.com/324#5
