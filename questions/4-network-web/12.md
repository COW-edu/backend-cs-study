# 크롬 주소창에 "www.google.com"을 치면 일어나는 일

# 10주차 - Network

> 크롬 주소창에 "[www.google.com](http://www.google.com/)"을 치면 일어나는 일
>

### 브라우저의 기능

- 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것
- 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해짐
- W3C(World Wide Web Consortium)에서 정한 명세를 대부분의 웹 브라우저가 따름

### 브라우저의 기본 구조

![스크린샷 2023-11-16 오후 5.19.52.png](..%2F..%2F..%2F..%2FDocuments%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-16%20%EC%98%A4%ED%9B%84%205.19.52.png)

1. 사용자 인터페이스 - 주소 표시줄, 이전 / 다음 버튼, 북마크 메뉴 등 요청한 창을 제외한 나머지 모든 부분
2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작 제어
3. 렌더링 엔진 - 요청한 콘텐츠 표시,
4. 통신 - HTTP 요청 등 네트워크 호출에 사용됨, 플랫폼에 독립적인 인터페이스
5. UI 백엔드 - 플랫폼에서 명시하지 않은 일반적인 인터페이스, OS 사용자 인터페이스 체계를 사용함
6. 자바스트립트 해석기 - JS코드를 해석하고 실행
7. 자료 저장소 - 쿠키 저장 등 자료를 저장하는 계층

### **www.google.com 입력**

1. 입력한 텍스트 정보 확인

   브라우저에서 사용자의 입력 텍스트가 검색어인지 URL인지 확인함 → 브라우저 엔진의 UI 스레드에서 진행
   입력한 텍스트가 검색어일 때, 브라우저는 검색 엔진의 URL에 검색어를 포함한 주소로 페이지를 이동

   URL일 때는 네트워크 호출을 수행함

   → www.google.com은 URL이므로 네트워크 호출을 수행함**

2. 네트워크 호출

   브라우저는 구글 서버와의 네트워크 통신을 통해 데이터를 가져와야 함

    - DNS서버에서 [google.com](http://google.com) 검색
        - 서버 검색 이전에 캐싱된 DNS 기록 확인
        - 일치하는 IP 주소가 존재하지 않으면 DNS 서버 요청으로 넘어감

    <aside>
    💡 Domain Name Server: URL의 이름과 IP주소를 저장하고 있는 데이터베이스

    </aside>

    - ISP (Internet Service Provider) 를 통해 DNS 서버가 호스팅하는 서버의 IP 주소를 찾기 위해 `DNS Query`를 전달함
        - 현재 DNS 서버에 원하는 IP 주소가 존재하지 않으면 다른 DNS서버를 방문하는 과정을 반복함
    - IP주소를 찾게 되면 브라우저는 구글 서버에 데이터를 요청하는 `HTTP Request`를 보내고, 이는 TCP / IP 프로토콜을 통해 서버로 전송됨
    - `HTTP Request`를 받은 구글 서버는 클라이언트의 요청 문서를 받아 바이트 형태로 변환 후 다시 클라이언트로 `HTTP Response`를 보냄.
        - 전달 과정에서 Status Code를 통해 서버 요청에 따른 결과 및 상태를 전송함

1. 렌더링

   브라우저 엔진은 구글 서버로부터 전달받은 데이터에 바이러스가 있는지 검사한 후, 렌더링 엔진에게 바이트 형태의 텍스트 문서 해석 및 렌더링을 요청함

   렌더링 엔진은 데이터를 바탕으로 렌더링 프로세스를 진행함

    - 렌더링 프로세스 과정
        1. HTML을 파싱해 DOM 트리 구축, CSS를 파싱해 CSSOM 트리 구축 (+ JS)
        2. DOM, CSSOM 트리를 통해 렌더 트리 구축
        3. 레이아웃 배치
        4. 페인트

    - HTML 파싱

        <aside>
        💡 바이트 -> 문자열 -> 토큰 -> 노드 -> DOM 트리

        </aside>

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3ea57f93-9c5c-4cdd-9555-f2f0c5e841f7/e42da9fa-8ee7-46a4-9e92-f5eec93c3580/Untitled.png)

        1. 바이트 형태의 HTML 문서를 응답받음
        2. 저장된 인코딩 방식에 따라 문자열로 반환함
        3. 변환된 문자열을 토큰으로 분해함
        4. 토큰을 내용에 따라 객체로 변환함
        5. 노드(객체)를 트리 구조로 구성해 DOM 트리를 생성함

- CSS 파싱, CSSOM트리 생성

  HTML파싱 중 CSS문서를 가져오는 link 태그를 인식하게 되면 DOM트리 생성을 중단하고 CSS 파싱이 진행됨

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3ea57f93-9c5c-4cdd-9555-f2f0c5e841f7/2794f794-f222-491d-824f-65acd0084b01/Untitled.png)

- JS 파싱, AST 생성

  script 태그를 인식하면 렌더링 엔진은 DOM 트리 생성을 중단하고 서버에서 해당 JS 리소스를 브라우저 엔진으로부터 받아오고 JS 엔진에게 제어권을 넘겨줌

  JS 엔진은 받아온 JS 리소스를 파싱해 AST(추상 구문 트리)를 생성하고 이를 바이트 코드로 변환해 실행함

  JS 파싱이 종료되면 렌더링 엔진은 다시 제어권을 돌려받고 DOM 생성을 이어나감

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3ea57f93-9c5c-4cdd-9555-f2f0c5e841f7/7d30b18b-2c28-44bd-b78b-1bbfabd077ae/Untitled.png)

    - 리플로우, 리페인트

      JS 코드에서 DOM 혹은 CSSOM을 변경하는 DOM API가 사용하여 변경된 DOM, CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃, 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링됨

- 렌더 트리 생성

  HTML, CSS 파싱 과정이 모두 끝나면 DOM트리와 CSSOM 트리를 서로 결합해 렌더 트리가 생성됨

    1. HTML 태그, body태그를 처리해 렌더 트리 루트를 구성함
    2. DOM 의 최상위 노드부터 순회하며 화면에 보여지지 않는 노드를 렌더 트리의 구성에서 제외함
    3. 화면에 보이는 나머지 노드에 CSSOM 규칙을 찾아 일치하는 스타일을 적용함

- 레이아웃

  렌더 트리 내 노드위 위치, 크기를 계산하고 이를 화면에 배치하는 과정

  노드의 위치는 x, y 좌표계를 사용

  최상위 노드 (0, 0) 부터 아래로 내려가며 계산을 진행함

- 페인트

  레이아웃 과정에서 계산된 정보를 바탕으로 각 노드를 화면에 그려주는 과정

  렌더 트리의 각 노드를 화면의 실제 픽셀로 변환(**Rasterizing)**해주는 작업