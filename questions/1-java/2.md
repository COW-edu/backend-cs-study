# GC 알고리즘의 종류에 대해서 설명해주세요.

## GC 동작 원리

1. **Stop The World**
2. **Mark and Sweep**

### Stop the World
- 가비지 컬렉션을 실행하기 위해 JVM이 어플리케이션의 실행을 멈추는 작업
- 가비지 컬렉션 실행 시 가비지 컬렉션을 실행하기 위한 스레드를 제외한 모든 스레드 중지,
가비지 컬렉션 종료 후 기존 스레드 재개

### Mark and Sweep
- Mark: 사용되는 메모리 식별(mark)
- Sweep: 식별되지 않은(un_marked) 메모리 제거

## GC 알고리즘 종류
- GC의 Stop the World에 의해 어플리케이션이 중지되는 문제를 최소화 하기 위해 다양한
GC 알고리즘이 존재

### Serial GC
- GC의 Young 영역은 Mark and Sweep의 방식으로 수행, Old 영역에서는 Mark Sweep에 더해 Compact라는
작업이 추가된 Mark Sweep Compact 알고리즘 적용
- CPU 코어가 1개일 때 사용하기 위해 개발된 알고리즘으로 CPU 코어가 여러 개인 운영 서버에서의
사용을 피해야 한다.

**Young 영역**: 새로 생성된 객체가 할당되는 Eden 영역 + 최소 1번의 GC 작업에서 생존한 객체가
복사되어 존재하는 영역 <br>
**Old 영역**: Young 영역에서 반복하여 살아남은 객체가 존재하는 영역(Survivor 영역에서 이동됨) <br>
**Compact**: Heap 영역을 정리하기 위한 단계로 유요한 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터
채워서 객체가 존재하는 부분과 객체가 존재하지 않는 부분으로 나누는 작업

### Parallel GC (Throughput GC)
- Serial GC와 처리 과정은 동일하지만 여러개의 쓰레드를 통해 GC를 수행하여 GC 오버헤드를 감소
- Java8까지 기본 가비지 컬렉터로 사용

### Parallel Old Gc
- Parallel GC Old 영역에서의 GC 알고리즘인 Mark Sweep Comapct가 아닌 GC를 수행한 영역에 대해
살아있는 객체를 식별하는 Summary 단계가 추가

### CMS(Concurrent Mark Sweep) GC
- CMS GC는 Parallel GC와 동일하게 여러 개의 쓰레드를 사용하며, **Mark Sweep을 Concurrent하게 수행**한다.
- 어플리케이션이 실행 중일 때에는 프로세서 자원을 공유하여 이용하기 때문에 다른 GC 알고리즘 보다
메모리와 CPU를 많이 사용함
- Java14부터 사용 중단

### G1(Garbage First) GC
- 똑같이 객체를 Eden 영역에 할당하고 Survivor로 카피하는 과정은 같지만 물리적으로 메모리 공간을 나누는 것이 아닌
Region이라는 개념을 도입해 Heap 영역을 균등하게 나눠 각 지역을 역할에 맞게 논리적으로 구분하여 객체를 할당
- Eden, Survivor, Old, Humonogous, Availalbe/Unused 역할 존재
- **Heap을 동일한 크기의 Region으로 나누고 가비지가 많은 Region을 우선적으로 GC 수행**
- Java9부터 기본 가비지 컬렉터로 사용 

- G1 GC와 다른 알고리즘들과의 차이
  - 다른 알고리즘들은 Old 영역 전체적으로만 GC를 수행해 메모리를 회수하지만, 
    G1은 이 작업을 훨씬 더 짧게 여러 컬렉션(영역)에 점진적으로 수행하여 적은 처리량
    비용으로 일시 중지 시간이 크게 단축시킬 수 있다.
  - CMS GC와 유사하게 G1은 메모리 회수 작업을 동시에 수행한다. 하지만 CMS는 Compaction 
    작업을 수행하지 않아 결국 긴 Full GC로 실행됩니다.

**Humonogous**: Region 크기의 절반을 초과하는 객체를 저장하는 Region <br>
**Available/Unused**: 사용되지 않은 Region
