# Stream에 대해서 설명해주세요.

## 스트림(Stream)

- 자바8에 새롭게 추가된 기능으로, 선언형으로 데이터(컬렉션, 배열, 파일, iterate...)를 처리할 수 있습니다.
- Stream을 사용하면 데이터를 쉽게 필터링, 변환, 집계할 수 있습니다.
- Stream은 **병렬처리**가 가능하도록 설계되었으므로 멀티 코어 프로세서를 활용하여 처리 속도를 높일 수 있습니다.

## Stream의 특징

### Stream은 데이터 구조가 아닙니다.
- Stream은 데이터를 저장하지 않습니다.
- Stream에서 요소를 추가하거나 제거할 수 없습니다.

### Stream은 생성, 중간, 최종 작업으로 나뉩니다.
- 아래에서 더 자세히 알아보겠지만, 대부분의 Stream 작업은 또 다른 새 Stream을 반환하며 함께 연결되어 작업 파이프 라인을 형성합니다.
- Stream 자체를 반환하는 작업을 중간 작업(Intermediate Operations)이라 합니다.(예: filter(), distinct(), sorted() 등)
- Stream 이외의 것을 반환하는 작업을 최종 작업(Terminal Operations)이라고 합니다.(예: count(), min(), max(), collect() 등)

### 병렬처리(Parallelism)
- 병렬처리는 멀티 코어에서 멀티 쓰레드를 동작시키는 방식입니다.
- 한 개 이상의 쓰레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말합니다.
- 많은 양의 데이터를 처리하면서 작업 속력을 높이기 위해서는 병렬로 처리하고 멀티 코어 아키텍처를 사용해야 합니다.
- Stream은 다중 스레드 코드를 작성하지 않고 병렬로 처리할 수 있습니다.

<img width="375" alt="스크린샷 2023-07-31 오후 10 01 31" src="https://github.com/Hoya324/backend-cs-study/assets/96857599/234b16dd-7262-465a-909f-4ef0dcbc5288">

**병렬 스트림**
- **병렬 스트림이란**, 각각의 스레드에서 처리할 수 있도록 **스트림 요소를 여러 청크로 분할한 스트림**입니다.(컬렉션에 **parallelStream**을 호출하기만 하면 병렬 스트림이 생성됩니다.) 
- 병렬 스트림은 전체 데이터를 서브 데이터들로 나눈 후 서브 데이터들을 병렬 처리하여 작업을 빠르게 수행하는 것을 구현한 것입니다.

**💡 그럼 모든 Stream을 병렬 스트림으로 사용하면 되는가?**
- 여기서 주의할 점은 **모든 병렬 Stream이 동일한 ThreadPool에서 thread를 가져와 사용한다**는 것입니다.
- Tread Pool을 이미 모두 점유하고 있다면 더이상 요청이 처리되지 않는 문제가 발생할 수 있습니다.
- 이러한 문제는 ForkJoinPool을 커스텀하게 제작함으로써 해결할 수 있습니다.
  - **Fork/Join Framework** : Java 7에 추가된 병렬 Stream의 내부 로직입니다.
  - **Fork / Join Framework**은 작업을 분할가능할 만큼 쪼개고, 쪼개진 작업을 별도의 work thread를 통해 작업 후 결과를 합치는 과정을 거쳐 결과를 만들어냅니다.

### Lazy Evaluation
- 직역하면 "게으른 연산"으로, 불필요한 연산을 피하기 위해 연산을 지연시키는 것을 말합니다.
- 필요할 때만 Stream의 요소를 평가하여 메모리 사용량을 줄이고 성능을 향상시킬 수 있습니다.

### Stream은 한 번만 통과할 수 있습니다.
- Stream은 두 번 이상 탐색할 수 없습니다.
  ```java
  List<String> nameList = Arrays.asList("Dinesh", "Ross", "Kagiso", "Steyn");          
  Stream<String> stream = nameList.stream();
  stream.forEach(System.out::println);
  stream.forEach(System.out::println);    
  //Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
  ```
  
### Stream은 내부 반복 방식으로 작동합니다.
- Stream은 내부 반복을 사용하면서 작업을 병렬적으로 처리하거나 최적화된 다양한 순서로 처리가 가능합니다.
- 반면에 for 문과 같은 외부 반복은 병렬성을 스스로 관리(synchronized 키워드 사용)해야 합니다.

<img width="538" alt="스크린샷 2023-08-01 오후 6 19 35" src="https://github.com/Hoya324/backend-cs-study/assets/96857599/56b7ea65-3dd4-41ad-9d54-084ea0586506">

## Stream 3가지 단계
1. **생성하기**: 배열, 컬렉션, 임의의 수, 파일 등 거의 모든 것을 가지고 Stream을 생성할 수 있습니다.
2. **가공하기**: 필터링(filtering) 및 맵핑(mapping) 등 원하는 결과를 만들어가는 중간 작업(intermediate operations)을 말합니다.
3. **결과 만들기**: 최종적으로 결과를 만들어내는 작업(terminal operations)입니다.

### Stream 생성
- **Stream.of()로 Stream 생성** : 특정 객체를 요소로 갖는 Stream을 생성하고 싶을 때 `Stream.of()` 를 사용할 수 있습니다.
  ```java
  Stream<String> stream = Stream.of("code", "chacha", "blog", "example");
  ```
- **Stream.empty()로 비어있는 Stream 생성** : `Stream.empty()` 는 어떤 요소도 갖고 있지 않는 Stream 객체를 생성합니다.
  ```java
  Stream<String> stream = Stream.empty();
  ```
- **컬렉션 타입(Collection, List, Set) Stream 생성** : 컬렉션 타입의 경우 인터페이스에 추가된 default 메서드 `stream`을 통해 스트림을 생성합니다.
  ```java
  List<String> list = Arrays.asList("a1", "a2", "b1", "b2", "c2", "c1");
  Stream<String> stream = list.stream();
  ```
- **Arrays.stream()으로 Stream 생성** : `Arrays.stream()` 을 이용하여 Stream을 생성할 수 있습니다.
  ```java
  String[] array = new String[]{"a1", "a2", "b1", "b2", "c2", "c1"};
  Stream<String> stream = Arrays.stream(array);
  ```
- **Stream.generate()로 Stream 생성**
  - `generate` 메소드를 이용하면 `Supplier<T>` 에 해당하는 람다로 값을 넣을 수 있습니다.
  - **Supplier<T>** : 인자는 없고 리턴값만 있는 함수형 인터페이스. 
  ```java
  public static<T> Stream<T> generate(Supplier<T> s) { ... }
  ```
  - 이 때 생성되는 스트림은 크기가 정해져있지 않고 무한하기 때문에 특정 사이즈로 최대 크기를 제한해야 합니다.
  ```java
  Stream<String> generatedStream = Stream.generate(() -> "gen").limit(5); // 5개의 “gen” 이 들어간 스트림이 생성됩니다.
  ```
- **Stream.iterate()로 Stream 생성**
  - `Stream.iterate()` 도 `generate()` 와 유사합니다. 하지만 `Stream.iterate()` 은 두 개의 인자를 받습니다. 첫번째 인자는 초기값, 두번째 인자는 함수입니다. 이 함수는 1개의 인자를 받고 리턴 값이 있습니다.
  ```java
  Stream<Integer> stream = Stream.iterate(0, n -> n + 2).limit(5);
  ```

### Stream 중간 연산
- **filter(Predicate\<T\>)** : Predicate를 인자로 받아 true인 요소를 포함한 스트림 반환
  - **Predicate\<T\>**: T에 대한 조건에 대해서 true/false를 반환하는 Functional Interface
- **distinct()** : 중복 값을 필터링
- **limit(n)** : 주어진 사이즈 이하 크기를 갖는 스트림 반환
- **skip(n)** : 처음 요소 n개 제외한 스트림 반환
- **map(Function)** : 매핑 함수의 result로 구성된 스트림 반환
- **flatMap()** :매핑된 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑함. map과 달리 평면화(1차원)된 스트림 반환

> 중간 연산은 모두 스트림을 반환한다.

### Stream 최종 연산
- **(boolean) allMatch(Predicate)** : 모든 스트림 요소가 Predicate와 일치하는지 검사
- **(boolean) anyMatch(Predicate)** : 하나라도 일치하는 요소가 있는지 검사
- **(boolean) noneMatch(Predicate)** : 매치되는 요소가 없는지 검사
- **(Optional) findAny()** : 현재 스트림에서 임의의 요소 반환
- **(Optional) findFirst()** : 스트림의 첫번째 요소
- **reduce()** : 모든 스트림 요소를 처리해 값을 도출. 두 개의 인자를 가짐
- **collect()** : 스트림을 reduce하여 list, map, 정수 형식 컬렉션을 만듬
- **(void) forEach()** : 스트림 각 요소를 소비하며 람다 적용
- **(Long) count** : 스트림 요소 개수 반환

**Optional 클래스란?**

Optional 클래스는 값의 존재나 여부를 표현하는 컨테이너 클래스입니다.
- optional을 이용해 null확인 관련 버그를 피할 수 있습니다.
- Optional은 값이 존재하는지 확인하고싶거나, 값이 없을 때 어떻게 처리할 것인지 강제하는 기능을 제공합니다.
- `isPresent()` 는 Optional이 값을 포함하면 참을 반환합니다.

## 스트림 사용 시 주의사항

### 스트림을 사용할 때 흔히하는 실수
1. **스트림 재사용**
  - 스트림은 한 번만 사용할 수 있습니다.
2. **"무한" 스트림 생성**
  - iterate나 generate를 이용하여 스트림을 생성할 때 제한을 두지 않으면 무한 스트림이 생성됩니다.
  - 또는 코드의 의도에 맞지 않는 순서로 스트림을 작성할 경우에도 무한 스트림이 생성될 수 있습니다.
    ```java
    // 의도치 않게 생성된 무한 스트림
    IntStream.iterate(0, i -> ( i + 1 ) % 2)
             .distinct()
             .limit(10)
             .forEach(System.out::println);
    
    System.out.println("complete");
    // limit(10)을 했으나, distinct가 먼저 실행되어 0과 1만 무한히 반복된다.
    ```
### 과도한 스트림의 사용은 오히려 가독성을 떨어트린다.
- 스트림을 과용하여 코드 가독성을 떨어트리고 유지 보수 비용을 늘리는 케이스 예시
```java
public class StreamAnagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                    groupingBy**(word -> word.chars().sorted()
                            .collect(StringBuilder::new,
                                    (sb, c) -> sb.append((char) c),
                                    StringBuilder::append).toString()))**
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    **.map(group -> group.size() + ": " + group)**
                    .forEach(System.out::println);
        }
    }
}
```

- 사전 하나를 훑어 원소 수가 많은 아나그램(알파벳이 같고 순서만 다른 단어) 그룹들 출력
```java
import static java.util.stream.Collectors.groupingBy;

// 코드 45-3 스트림을 적절히 활용하면 깔끔하고 명료해진다. (Effective Java 271쪽)
public class HybridAnagrams {
    public static void main(String[] args) throws IOException {
				
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);
				//파일 내용은 java 문자열 stream 으로 생성
        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(groupingBy(word -> **alphabetize(word))**) 
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    .forEach(g -> System.out.println(g.size() + ": " + g));
        }
    }

    private static String **alphabetize**(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

## Reference
- [Java 8 스트림: 초보자 가이드](https://javaconceptoftheday.com/java-8-streams-beginners-guide/)
- [Java 스트림 Stream](https://futurecreator.github.io/2018/08/26/java-8-streams/)
- [자바 병렬 처리 와 성능측정 - parallelStream](https://thalals.tistory.com/364)
- [병렬 스트림의 문제 및 해결](https://sabarada.tistory.com/102)
- [Lazy Evaluation 이란?](https://dororongju.tistory.com/137)
- [Java - Stream 생성 방법 및 예제](https://codechacha.com/ko/stream-creation/)
- [외부 반복과 내부 반복은 어떤 차이가 있을까?](https://github.com/woowacourse-study/2022-modern-java-in-action/issues/12)
- [스트림을 사용할 때 주의할 점](https://codingwell.tistory.com/127)
