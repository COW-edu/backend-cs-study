# Map의 구현체들에 대해서 설명해주세요.

## Map이란?

* key-value 구조로 구성된 데이터를 저장하는 자료구조
* 데이터 검색에 최적화되어 있다.
* key는 중복 저장될 수 없지만, 값은 중복 저장될 수 있다.
* 구현 클래스로는 HashMap, LinkedHashMap, Properties, TreeMap이 있다.

## HashMap
* 해시맵은 Hash Table을 이용해 만들어진 Map의 구현체이다.
* 특정 key는 해시 함수를 거쳐 bucket(저장 공간) 접근할 수 있는 index로 변환된다.
* 해당 index에 맞는 bucket에 key-value를 저장한다.

### 장점
* key가 해시 함수를 통해 bucket의 위치를 가리키는 index로 변환되므로, 값 검색에 있어 다른 ArrayList, LinkedList대비 빠른 성능을 보임.
* key는 nullable하게 유지할 수 있다.

### 단점
* bucket은 배열의 개념이므로, 일정 수준의 데이터가 쌓이면 bucket을 resizing하는 작업이 필요한데, 이때 지연시간이 소요된다.
* 데이터 저장을 위해 메모리를 많이 사용한다.

### 언제 사용하는가?
* key를 이용한 데이터 저장과 접근이 필요한 경우
* 메모리보다 성능이 우선인 경우
* 대략적인 데이터 크기가 예상이 되는 경우
* insert, delete 작업이 자주 일어나는 경우

```java
import java.util.HashMap;

public class Sample {
    HashMap<Key, Value> hashMap = new HashMap<>();
    // 입력
    hashMap.put("cafe", "카페");
    
    // 조회
    String value = hashMap.get("cafe"); // 카페
    
    // 삭제
    hashMap.remove("카페");

    // key 값을 출력
    for (String key : hashMap.keySet()) {
        System.out.println(key);
    }
    
    // value 값을 출력
    for (String value : hashMap.values()) {
        System.out.println(value);
    }
}

```

<br>

## TreeMap
* 기본적으로 Red-black Tree를 이용해 만들어졌다.
* HashMap과 달리 key값을 기준으로 오름차순으로 정렬된 key를 반환받을 수 있다.
  * 문자의 경우에는 unicode값을 정렬 기준으로 한다.
* 정렬된 데이터를 조회하는 범위 검색의 경우에는 성능이 좋다.
* HashMap 대비 필요한 메모리 양만 사용하므로, 상대적으로 메모리를 절약할 수 있다.

### 단점
* 삽입이나 삭제 시, Node를 재배치하는 연산이 발생할 수 있다.
* Map 구현체 중 검색 속도가 가장 느리다.

### 언제 사용하는가?
* 데이터의 개수가 예측되지 않는 경우
* insert, delete가 적을 때
* 정렬된 key가 필요한 경우

<br>

## LinkedHashMap
* HashMap을 상속하여 만든 클래스이다.
* 차이점은 Node객체를 Entry 객체로 감싸서, 입력된 키의 순서를 보존한다는 점이다.
* HashMap과 달리 순서를 linked-list를 이용해서 관리하므로, 더 많은 메모리를 필요로 한다.
* key나 값의 저장된 순서가 중요한 경우 유용하다.

```java
import java.util.LinkedHashMap;

public class Example {
    LinkedHashMap<String, String> map = new LinkedHashMap<>();

    // key 값을 출력
    for (String key : map.keySet()) {
        System.out.println(key);
    }

    // value 값을 출력
    for (String value : map.values()) {
        System.out.println(value);
    }
}

// 저장된 순서대로 key, value값이 출력된다.
```

<br>

![image](https://velog.velcdn.com/images/sweet_sumin/post/489a680d-50f2-4216-9fbb-bc2a609aab67/image.png)
* 구현된 로직을 살펴보면 HashMap과 달리 accessOrder라는 값이 있다.
* accessOrder는 Entry에 access하는 mode를 나타낸다.
  true일 경우 입력된 순서 중에 access빈도 낮은 것들부터 접근하고, false일 경우 입력된 순서로 Entry에 접근한다.

## Hashtable
* HashMap과 같은 동작을 하는 클래스이다.
* 기존 코드와의 호환성을 위해 남겨진 것으로, HashMap을 사용하는 것이 권장된다. 
* 비유하자면 ArrayList - Vector의 관계와 유사하다.
* 장점으로, **thread-safe** 하다. 따라서, multi-thread 환경에서 데이터 무결성을 보장한다.

## References
* https://d2.naver.com/helloworld/831311
* https://www.codelatte.io/courses/java_programming_basic/KW7N6AHSIJ00UUS4
* https://crazykim2.tistory.com/589
* https://velog.io/@sweet_sumin/Map%EA%B3%BC-Multimap-TreeMap-HashMap-LinkedHashMap-%EC%B0%A8%EC%9D%B4
* https://lotuslee.tistory.com/126
