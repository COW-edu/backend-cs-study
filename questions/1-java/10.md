## Question

> Java에서 동시성 문제를 제어하는 방법들에 대해서 설명해주세요.
> 

## 프로세스와 스레드

JVM → 자바 프로세스 → 프로세스 내부 스레드 수행

프로세스: 실행 중인 프로그램(OS로부터 리소스를 할당받는 작업의 단위)

<img width="327" alt="스크린샷 2023-08-03 오전 8 15 39" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/d493253d-cea1-4179-a4b4-6a7e27ce0516">

각 프로세스는 독립된 메모리 영역을 할당받고, 최소 하나 이상의 스레드를 가짐

별도의 주소 공간에서 실행되고, 변수나 자료구조 등에 접근 불가함

<img width="613" alt="스크린샷 2023-08-03 오전 8 19 27" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/007b906d-3c71-43ae-b512-14dbad09d7e0">

### 자바의 멀티 스레드 환경

자바 → 멀티 스레드 환경

한 프로세스 내에서 멀티태스킹이 가능함 (두 가지 이상의 작업을 동시에 처리하는 것)

멀티 스레드 환경은 공유하는 영역이 많아서 단일 스레드 방식보다 작업 전환(Context Switching) 오버헤드가 작아, 메모리 리소스가 상대적으로 적다.

하지만 공유 자원으로 인한 단점도 존재한다! → **동시성(Concurrency) 문제**

### 동시성 vs 병렬성

<img width="606" alt="스크린샷 2023-08-03 오전 8 04 12" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/a9635a43-5222-41f9-9837-c9d20a1f9980">

Case 1: 동시성을 만족하지만 병렬성을 만족하지 않는다

Case 2: 둘 다 만족한다

- 동시성 - 동시에 실행되는 것처럼 보이는 것
    - 두 개 이상의 task를 수행할 때, 각각의 task는 **다른 task의 수행 시점에 상관없이 수행이 가능하다**는 것 → N개의 task 실행 시간이 타임라인에서 겹칠 수 있음
    - 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로, 멀티 태스킹을 위해 여러 게의 스레드가 번갈아가면서 실행되는 성질
    - 멀티 스레드 환경이기에 동시성을 만족시킬 수 있는 것이지, 둘 사이의 연관 관계가 있는 것은 아니다. 싱글 스레드 환경에서도 동시성을 만족할 수 있다
    - 코틀린의 ‘코루틴’도 루틴이라는 단위(함수)로 서로 협력이 가능하며, 동시성을 지원하고 비동기 처리를 도와줄 수 있다
- 병렬성 - 실제로 동시에 실행되는 것
    - 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 하나 이상의 스레드를 포함하는 각각의 코어들이 동시에 실행되는 성질
    - 물리적인 시간에 동시에 수행됨
    - 네트워크 상 여러 컴퓨터에게 분산 작업을 요청하는 분산 컴퓨팅을 예시로 들 수 있음

⇒ 동시성은 병렬성을 가지기 위한 필요조건이지만, 충분조건은 아니다.

## 동시성 문제란?

동일한 데이터에 두 개 이상의 스레드, 혹은 세션에서 가변 데이터를 동시에 제어할 때 나타나는 문제로, 하나의 세션이 데이터를 수정 중일 때 다른 세션에서 수정 전의 데이터를 조회해 로직을 처리함으로서 데이터의 정합성이 깨지는 문제를 말함

예시: 재고 시스템

멀티 스레드 환경에서 가변 데이터에 접근하는 상황 

<img width="739" alt="스크린샷 2023-08-03 오후 2 43 08" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/01f1be75-d29e-4f0b-87e3-635f48592a94">

우리가 예상한 상황은 위의 상황이겠지만,

<img width="678" alt="스크린샷 2023-08-03 오후 2 48 10" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/57b4e8f7-5c55-499c-a11d-34dd0144a883">

이처럼 **같은 데이터를 동시에 변경**하려 할 때 작업 중 하나가 누락될 수 있다

이를 **레이스 컨디션(Race Condition)**이라 한다

## 동시성 문제를 제어하는 방법

keyPoint: 가변 데이터에 대한 순차적 접근

### Synchronized

멀티 스레드 환경에서 스레드 간 데이터 동기화를 위해 자바에서 제공하는 키워드

현재 데이터를 사용하는 스레드를 제외하고 나머지 스레드들의 데이터 접근을 막하 순차적으로 데이터에 접근할 수 있도록 해줌

```java
@Transactional
public synchronized void decrease(final Long id, final Long quantity) {
    Stock stock = stockRepository.findById(id).orElseThrow();
    stock.decrease(quantity);
    stockRepository.saveAndFlush(stock);
}
```

- 문제점
    
    하나의 프로세스 안에서만 보장됨
    
    Synchronized는 각 프로세스의 동시 접근 제어만을 보장해주므로, 서버가 1개일 땐 문제없지만 두 개 이상일 경우 다른 서버에서 가변 공유 데이터에 접근하는 것을 막을 수 없음
    

### Database Lock (MySQL)

Lock에는 공유락과 베타락 두 종류가 있다

여기에서 사용하는 lock은 데이터를 변경하고자 할 때 사용하는 Exclusive Lock임

- **Pessimistic Lock**
    
    데이터에 lock을 걸어서 정합성을 맞추는 방법
    
    베타lock을 걸게 되면 다른 트랜잭션에서는 lock이 해제되기 전에 데이터를 가져갈 수 없음. 
    
    자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 락을 걸었으므로 비관적(Pessimistic) 락이라고 함
    
    한 서버가 DB 데이터를 가져올 때 Lock을 걸면, 다른 서버에서는 한 서버의 작업이 끝나 lock이 풀릴 때까지 데이터에 접근하지 못함
    
    <img width="695" alt="스크린샷 2023-08-04 오후 9 31 05" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/66173dbe-4206-4f67-8d72-4aec70105464">
    
    ```java
    public interface StockRepository extends JpaRepository<Stock, Long> {
    
        @Lock(value = LockModeType.PESSIMISTIC_WRITE)
        @Query("select s from Stock s where s.id = :id")
        Stock findByWithPessimisticLock(final Long id);
    }
    ```
    
    단점
    
    - 데이터 자체에 별도로 락을 걸으므로 동시성이 떨어져 성능 저하가 발생할 수 있음
    - 읽기 작업이 많은 DB에는 손해가 더 큼
    - 서로 자원이 필요할 때, 데드락 가능성
- **Optimistic Lock**
    
    실제로 Lock을 이용하지 않고 버전을 이용함으로써 정합성을 맞추는 방법
    
    데이터를 읽은 후 update를 수행할 때 현재 읽은 버전이 맞는지 확인하여 업데이트함
    
    데이터에 락을 걸어서 선점하지 않고, 동시성 문제가 발생하면 그 때 처리하기 때문에 낙관적(Optimistic) 락이라고 함
    
    ```java
    Entity
    @Getter
    @NoArgsConstructor
    public class Stock {
    
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        private Long id;
    
        private Long productId;
    
        private Long quantity;
    
    	//버전 칼럼 추가
        @Version
        private Long version;
    
        //로직 생략
    
    }
    ```
    
    ```java
    public interface StockRepository extends JpaRepository<Stock, Long> {
    
        @Lock(value = LockModeType.PESSIMISTIC_WRITE)
        @Query("select s from Stock s where s.id = :id")
        Stock findByWithPessimisticLock(final Long id);
    
    	//Optimistic Lock
        @Lock(value = LockModeType.OPTIMISTIC)
        @Query("select s from Stock s where s.id = :id")
        Stock findByWithOptimisticLock(final Long id);
    
    }
    ```
    
    버전을 확인하며 데이터를 처리함
    
    단점
    
    - 업데이트가 실패했을 때 재시도 로직을 개발자가 직접 작성해야함
    - 충돌이 빈번하게 일어나게 되면 롤백 처리를 해주어야하므로 성능이 떨어짐
- **Named Lock**
    
    이름을 가진 metadata locking
    
    row 혹은 table 단위로 락을 거는 Pessimistic Lock 방식과는 다르게, Named Lock은 metadata 단위로 락을 건다
    
    <img width="707" alt="스크린샷 2023-08-04 오후 9 40 34" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/fc1862ba-cd50-4aa6-b355-9030bee23cfe">
    
    Stock에 락을 걸지 않고, 별도의 공간에 락을 건다
    
    ```java
    public interface LockRepository extends JpaRepository<Stock, Long> {
    
        @Query(value = "select get_lock(:key, 3000)", nativeQuery = true)
        void getLock(String key);
    
        @Query(value = "select release_lock(:key, key)", nativeQuery = true)
        void releaseLock(String key);
    }
    ```
    
    장점
    
    - 분산 락을 구현할 때 사용할 수 있음
    
    단점
    
    - 트랜잭션 종료 시 락 해제와 세션관리에 주의해야 함

### Redis

Redis를 사용해 분산 락을 구현함으로써 데이터 정합성 문제를 해결함

분산 락이란?

→ Race Condition에서 하나의 공유 자원에 접근할 때 데이터의 결함이 발생하지 않도록 원자성을 보장하는 기법

락 획득 방식에 따라 두 가지 사용 방법이 있음

- Lettuce
    
    공식적으로 분산 락 기능을 제공하지 않아 직접 구현해서 사용해야함
    
    락 획득 방식: Spin Lock
    
    → 락을 획득하지 못한 경우 redis에 계속해서 요청을 보내는 방식
    
    <img width="473" alt="스크린샷 2023-08-04 오후 9 58 11" src="https://github.com/Youngcircle-kim/CowSubway-BackEnd/assets/104254012/bed31207-f0a7-404e-83c4-10581d067086">
    
    redis에 부하가 생길 수 있음
    
    이를 막기 위해 락 획득을 재시도하는 시간(term)을 길게 설정하게 되면, 락을 획득할 수 있음에도 불구하고 무조건 설정된 시간을 기다려야 하는 비효율적인 경우가 발생할 수 있음
    
- Redission
    
    락 획득 방식: Pub / Sub (발행 / 구독) 방식
    
    락이 해제될 때마다 구독 중인 클라이언트에게 ‘락 획득 가능’이라는 알림을 보내기 때문에 클라이언트 측에서는 락 획득에 실패할 경우 redis에 락 획득 요청을 하는 과정이 사라지므로 계속된 요청으로 인한 부하가 발생하지 않게 됨
    

## 용어 정리

- Context Switching: 스케줄러가 기존 실행 프로세스를 우선순위로 인해 미루고 새 프로세스로 교체해야 할 때, 프로세스 상태 값을 교체하는 작업. 프로그램 카운터와 스택 포인터 등으로 인해 스위칭이 가능함
- 스케쥴러: 어떤 프로세스에게 자원을 할당할지 순서와 방법을 결정하는 운영체제 커널의 모듈
- 오버헤드: 사용된 시간과 메모리의 양. 성능을 결정하는 중요한 요소
- 프로그램 카운터(PC): 마이크로프로세서 내부에 있는 레지스터 중 하나로서, **다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정하는** 주소 레지스터
- 스택 포인터(SP): CPU안에서 **스택에 데이터가 채워진 마지막 위치를 가리키는 레지스터**
- 커널: 운영체제 중 **항상 필요한 부분**만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 되는데, 이때 **메모리에 상주하는 운영체제의 부분**
