# Java Code가 실행되는 과정에 대해서 설명해주세요.

## 목차
- [목차](#목차)
- [JVM이란 무엇인가](#JVM이란-무엇인가)
- [컴파일 하는 방법](#컴파일-하는-방법)
- [실행하는 방법](#실행하는-방법)
- [바이트코드란 무엇인가](#바이트코드란-무엇인가)
- [JVM의 구성 요소](#JVM의-구성-요소)
- [JIT 컴파일러란 무엇이며 어떻게 동작하는가](#JIT-컴파일러란-무엇이며-어떻게-동작하는가)
- [JDK와 JRE의 차이](#JDK와-JRE의-차이)

## JVM이란 무엇인가
<!-- 텍스트 입력하기 -->
JVM이란 Java Virtual Machine의 줄임말로, Java가 플랫폼과 OS에 독립적으로 프로그램을 작성하고 실행하도록 도와주는 표준 및 구현체이다. 이를 직역하면 '자바를 실행하기 위한 가상 기계' 라고 할 수 있는데, 영어권에서는 컴퓨터를 머신(machine) 이라고도 부르기 때문에 '자바를 실행하기 위한 가상 컴퓨터'라고 이해할 수 있다.
* 자바로 작성된 애플리케이션은 모두 JVM에서만 실행된다.
* Write once, run anywhere(한 번 작성하면 어디서든 실행된다.) 이라는 자바의 장점을 가능하게 한다.

## 컴파일 하는 방법
컴파일(compile)이란 고급 언어로 작성된 소스코드를 컴퓨터가 이해할 수 있도록 기계어(machine language)로 변환하는 과정을 의미한다. 
* JAVA에서는 .java 파일을 .class파일로 변환하는 과정이다.

## 실행하는 방법
콘솔에서 JAVA 애플리케이션을 실행시켰을 때, 내부적인 진행순서는 다음과 같다.
1. 프로그램의 실행에 필요한 클래스 파일(.class)를 로드한다.
2. 클래스 파일을 검사한다.(파일형식, 악성 코드 체크)
3. 지정된 클래스에서 main 메소드를 호출한다.

## 바이트코드란 무엇인가
가상 머신이 이해할 수 있는 바이너리 코드이다. 고급 언어로 작성된 소스코드를 가상 머신이 이해할 수 있는 중간 코드로 컴파일된 형태의 파일(.class)이다.
JVM은 바이트코드를 읽어 들여서 컴퓨터가 이해할 수 있는 언어로 변환한다.
* 바이너리 코드란? CPU가 이해할 수 있는 언어이다.

## JVM의 구성 요소
![image](https://github.com/MJU-Capstone-Album2Me/REPOST-Backend/assets/59856002/aa65f8c1-6a16-4332-bf5a-d97b78a64cab)
JVM의 구성 요소는 크게 **3가지로 나눌 수 있다.**
* 클래스 로더(Class Loader) : JVM 내로 클래스파일을 로드하는 시스템 구조다. 런타임 시에 동적으로 클래스를 로드한다. .jar 파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다.
  * 클래스 로더는 크게 Loading, Linking, Initialization 의 세 가지 역할을 수행한다.
  * Loading은 .class 파일을 jvm내로 로드하며, Linking 작업을 통해 해당 파일을 검증하고, initialization에서 static field를 초기화한다.

* 런타임 데이터 영역(Runtime Data Areas) : JVM이 프로그램을 수행하기 위해 OS 위에서 실행되면서 할당받는 메모리 영역이다. JVM Stack, Heap, Method Area, Runtime Constant pool 등이 존재한다.
* 실행 엔진(Execution Engine) : 클래스를 실행시키는 역할을 한다. 클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 자바 바이트코드는 실행엔진에 의해 실행된다.
    * Interpreter : 프로그램을 한 줄씩 읽어들이며 동시에 실행하는 역할
    * JIT Compiler : 하단 참고
    * Garbage Collector : 프로그램이 동적으로 할당한 메모리 영역에서 더 이상 필요가 없는 영역을 해제하는 역할
      참고하면 좋을 자료 : https://catch-me-java.tistory.com/12

## 왜 JVM의 실행 엔진은 인터프리터를 사용하는가?
* 인터프리터와 비교하면 컴파일러의 속도가 빠르긴 하나, 이는 특정 기계에 종속될 수 있다는 가능성을 내포한다.
* 자바 인터프리터는 바이트코드를 한 줄씩 인터프리팅 하므로, 자바의 WORA 철학을 충족시킨다.
* 그러나, 인터프리터 방식은 컴파일러보다 속도가 느리므로, JVM은 JIT 컴파일러를 이용하여 이를 극복하고자 한다.

## JIT 컴파일러란 무엇이며 어떻게 동작하는가
* 자바의 컴파일 방식
  자바 소스 코드(.java)를 컴파일하면 바이트 코드(.class)파일로 변환된다. 이 파일을 기계어로 인터프리팅 하는 두 가지 프로세스가 필요하다.
  인터프리터 방식의 느린 속도 문제를 JIT 컴파일러를 이용하여 개선시킬 수 있다.
* JIT 컴파일러란?
  JIT는 Just In Time의 약자이며, 한 번 읽어서 기계어로 변경한 소스코드는 다시 컴파일하지 않는다. 즉 반복되는 코드를 인터프리터를 거치지 않고 컴파일러로 컴파일 시키는 역할이다.

## 런타입 데이터 영역이란?
![image](https://github.com/MJU-Capstone-Album2Me/REPOST-Backend/assets/59856002/e972d3b1-9a68-4562-bb79-f060b1ce60e9)

### Method 영역
Method Area 에는 인스턴스 생성을 위한 객체 구조, 생성자, 필드 등이 저장된다.
Runtime Constant Pool 과 static 변수, 그리고 메소드 데이터와 같은 Class data 들을 관리한다.
또한 인스턴스 생성에 관한 정보도 있기 때문에, 모든 Thread간에 공유된다.

### Heap 영역
Heap 영역은 **코드 실행**을 위한 자바 객체 및 JRE 클래스가 올라간다. 
또한, 문자열에 대한 정보를 가진 String Constant Pool 뿐만이 아니라 실제 데이터를 가진 인스턴스, 배열 등이 저장된다.
모든 Thread가 공유하며, 이 때문에 동시성 이슈가 발생할 수 있다.

### Stack 영역
정적인 영역이며, 각 Thread 별로 따로 할당됩니다. 또한, 각각의 Thread 별로 메모리를 따로 할당하기 때문에 동시성 문제에서 자유롭다는 점도 있습니다.
기본 자료형(primitive type)의 데이터가 저장됩니다. Heap 영역이 가진 데이터의 참조값을 저장하며, Stack 영역을 통해 쓰레드 간의 공유가 이루어집니다.

## Native Method Stack 영역
Java 로 순수하게 Java 로 구성된 코드만을 사용할 수 없는 시스템의 자원이나 API 가 존재함.
다른 프로그래밍 언어로 작성된 메소드들을 Native Method 라고 한다. 
다시 말해 Java 로 작성되지 않은 메소드를 다루는 영역이다. 주로 C, C++ 언어로 작성된 API와 함께 이용되는 경우가 많다.

### PC Register
각 쓰레드는 결국 각 메서드를 실행할 텐데, 각 쓰레드끼리도 서로 동시에 메서드를 실행하기 위한 환경이 필요하다.
이때 JVM이 실행할 명령어 주소값을 저장할 공간이 필요한데, 이를 PC 레지스터가 담당한다.

## JDK와 JRE의 차이
* JDK(Java Development Kit) : JRE + 개발에 필요한 실행 파일들(javac.exe)등
* JRE(Java Runtime Environment) : JVM + 클래스 로더 + 클래스 라이브러리(Java API) 오직 자바 프로그램을 실행할 목적이라면, JRE만 있어도 실행할 수 있다.

<br>

## Q&A

### JIT 컴파일러가 이용되는 조건은 무엇인가?
* 실행 시점에서 인터프리터와 같이 기계어 코드를 생성하나, 해당 코드가 컴파일링이 필요하다고 판단되면 컴파일 후에 별도로 캐싱을 하게 된다.
* JIT 컴파일은 실시간으로 일어나며, 전체 코드의 필요한 부분만 변환한다.
* JIT 컴파일러가 컴파일하는 조건은 얼마나 자주 코드가 실행됐는가? 이다. 각 메서드마다 호출 횟수를 누적하여 그 횟수가 특정 임계치를 초과할 때 컴파일될 자격이 있다고 판단한다.
* 메서드가 호출된 횟수, 루프 내 반복 횟수의 합을 기반으로 임계치를 결정한다. 이를 **컴파일 임계치**라고도 한다.
* 컴파일이 필요한 경우 별도의 큐에 저장되어 컴파일 쓰레드에 의해 컴파일링된다.

### JVM 웜업이란 무엇인가?
* 어플리케이션을 시작하는 단계에서는 캐시된 데이터가 없기 때문에 JIT 컴파일러의 성능이 나쁘다.
* 만약 빠른 응답을 필요로 하는 API의 경우에 문제가 생길 수 있다.
* 따라서, 어플리케이션 시작 후에 의도적으로 미리 로직을 실행하여 기계어가 캐시에 저장되고 최적화 할 수 있는 과정이 필요한데, 이를 JVM warm up이라고 한다.

## References
* 자바의 정석 - 남궁성
* https://tecoble.techcourse.co.kr/post/2021-07-12-jvm-jre-jdk/
* https://hyeinisfree.tistory.com/26
* https://velog.io/@qwerty1434/ifkakao-JVM-warm-up
