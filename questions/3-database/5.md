# 인덱스를 설정하는 기준들에 대해 설명해주세요.

## 인덱스(Index)란?
* 인덱스 지정 컬럼들을 기준으로 메모리 영역에 목차를 생성하는 것이다.
    * 기본적으로 인덱스가 없는 경우, Full Table Scan을 하게 되며, 탐색의 시간 복잡도는 O(n)이 소요된다.
    * insert, update, delete 성능을 희생하고 조회 성능을 늘리는 것
* 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에
  데이터의 물리적 주소와 함께 저장된다.
* 인덱스 생성 컬럼에 where 조건을 걸면 옵티마이저에서 판단하여 생성된 인덱스를 타고, 인덱스에
  저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 방식으로 동작한다.
* 결과적으로 검색 속도의 향상을 가져올 수 있다.
  ![img](https://github.com/COW-edu/backend-cs-study/assets/59856002/2caac798-272d-4bb7-b9a5-77448fda0fbf)

## 인덱스(Index)의 자료 구조

### Hash Table
* key - value 형식으로 시간복잡도 O(1) time에 검색을 완료할 수 있다.
* where 조건의 = 연산에는 효율적이지만, 부등호 연산에는 부적합하다.
* 해시 충돌 문제가 발생할 수 있다.

### B-Tree
* 자식 노드가 2개 이상이며, 모든 리프노드들이 같은 레벨을 가질 수 있도록 하는 balanced-tree이다.
* 특정 컬럼의 key(값)에 대항하는 노드에 데이터의 위치(value)를 저장한다.
* BST처럼 왼쪽 자식은 항상 Key보다 작은 값을, 오른쪽 자식은 큰 값을 가진다.
* 이를 통해 범위 검색에서 해시 테이블보다 효율적인 탐색이 가능하다.
    * 평균 시간 복잡도는 O(logN)임을 보장.

### B+ Tree
* B Tree를 확장 및 개선한 자료 구조로서, 말단의 리프 노드에만 데이터의 위치를 관리한다.
* 중간 브랜치 노드에 Value가 없어서 B-Tree보다 메모리를 덜 차지하는 만큼, 노드의 메모리에 더 많은 Key를 저장하고, 결과적으로 Tree의 높이를 줄일 수 있다.

## 인덱스의 특징
* 인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행된다.
* 인덱스의 두번째 컬럼은 첫 번째 컬럼에 의존되어 정렬되어있다.
* 인덱스의 수는 3~4개 정도가 적당하다.
    * 인덱스가 너무 많으면 삽입,수정,삭제시마다 인덱스 수정이 일어나므로 성능이 저하된다.

### 페이지란?
InnoDB(MYSQL)은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 하며, 인덱스 역시 페이지 단위로 관리된다.
페이지는 16KB로 크기가 고정적이다.

### 인덱스(Index)의 장점
* 인덱스의 가장 큰 특징은 데이터들이 정렬된다는 점이다.
    * 이는 조건 검색에서 굉장한 효율을 지니게 된다.(select절 성능 향상)
    * Order by가 불필요하며, MIN, MAX의 효율적인 처리가 가능하다.

### 인덱스(Index)의 단점
* 정렬된 상태를 계속 유지시켜야 한다는 점이다.
* 레코드 내에 데이터 수정이 잦을 경우 좋지 않다.(insert, update, delete 성능 저하)
    * INDEX 테이블, 원본 테이블 두 군데에 데이터 수정 작업이 모두 이루어져야 하기 때문이다.
    * 인덱스 관리를 위해 저장된 데이터의 약 10% 정도의 추가 데이터 공간이 필요하다.
    * 초기 index 생성 리소스가 소요됨.

## 인덱스(Index) 타입 종류

### 클러스터형 인덱스(Clustering index)(=PK 인덱스)
![클러스터링 인덱스](https://github.com/COW-dev/ddingdong-be/assets/59856002/89625001-ec02-4905-89f6-a4ff61e14d26)
* Root 페이지는 Leaf 페이지의 주소, Leaf 페이지는 실제 데이터 페이지로 구성됨.
* 인덱스 페이지에 데이터가 직접 저장되어 데이터의 물리적인 정렬순서가 인덱스의 정렬순서와 같다.
* 항상 페이지는 정렬 상태를 유지한다.
* PK 설정시, 자동으로 생성된다고 하여 PK 인덱스라고도 부름.
* 한 테이블에 1개만 만들 수 있다
* 클러스터 인덱스는 정보 공간을 적게 사용하면서 테이블 공간 자체를 활용
* 실제 인덱스에 순서에 맞게 물리적인 저장도 함께 저장.

![img_1](https://github.com/COW-edu/backend-cs-study/assets/59856002/b1fb4ea8-f605-4bcc-a32c-b058d6228efa)
인덱싱을 하면 루트 페이지가 만들어진다. 이때 루트 페이지란 각 데이터 페이지의 첫 번째 데이터를 담고 있다.
데이터 페이지 자체를 인덱스 페이지로 삼는 것이다.

![img_3](https://github.com/COW-edu/backend-cs-study/assets/59856002/a589ba04-46c0-4805-b2ea-74023b22fcb3)
데이터 삽입 시, 1000번 페이지에 공간이 없어 페이지 분할이 일어난다.
이렇게 삽입, 삭제 시마다 페이지 분할이나 정렬이 필요하므로 성능이 나빠지게 된다.

### 보조 인덱스(Secondary index, Non Clustered Index)
![image](https://github.com/COW-dev/ddingdong-be/assets/59856002/c97805f6-19a1-463a-8936-84a4d5507b0a)
* 데이터 페이지는 그냥 두고, 별도의 페이지에 인덱스를 구성한다
* 레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬된다.
* 보조 인덱스의 리프 페이지는 데이터가 위치하는 주소값(RID)이다.
* 포인터(RID): '파일그룹번호+데이터페이지 번호 + 페이지 내의 로우 번호'으로 구성되는 포인팅 정보.
* 보조 인덱스는 여러 개 생성할 수 있다.(데이터 페이지에 직접 변화를 주지 않기 때문이다.)
![img_2](https://github.com/COW-edu/backend-cs-study/assets/59856002/0f2506de-fc9a-439a-9a1b-96c7eb17980e)

![img_4](https://github.com/COW-edu/backend-cs-study/assets/59856002/e7244896-072f-41a5-9e2d-d594b8be0dd6)
데이터 조회 시, 거쳐야 하는 조회 DEPTH는 3이다.
이러한 차이는 데이터의 양이 많을수록 클러스터 인덱스에 비해 성능이 크게 뒤떨어진다.

![img_5](https://github.com/COW-edu/backend-cs-study/assets/59856002/1b4e15fc-51ef-451c-a07e-254b178a3796)
데이터 삽입 시, 페이지 빈곳에 데이터를 넣고 리프 페이지에서 매핑만 하면 되기 때문에, 페이지 분할이 일어나지 않는다.


| 비교       |      클러스터 인덱스      |        보조 인덱스        |
|:---------|:------------------:|:--------------------:|
| 검색(조회)   |        빠르다         |         느리다          |
| 입력/수정/삭제 |        느리다         |         빠르다          |
| 사용 메모리   |         적다         |          많다          |
| 인덱스      |    인덱스가 주요 데이터     |  인덱스가 데이터의 사본(Copy)  |
| 개수       |      테이블 당 1개      |      테이블에 여러 개       |
| 리프 노드    |   리프 노드 자체가 데이터    | 리프 노드는 데이터가 저장되는 위치  |
| 저장값      |  데이터 저장한 블록의 포인터   | 값과 데이터의 위치를 가리키는 포인터 |
| 정렬       | 인덱스 순서와 물리적 순서가 일치 | 인덱스 순서와 물리적 순서가 불일치  |

### 왜 빠른가?
네트워크에서는 한 번에 데이터를 가져올 수 있는 양(page)가 한계가 있다.
따라서 범위검색을 하였을 때, 물리적인 저장 위치가 서로 인접해 있기 때문에 용이하다.
하지만, 보조 인덱스의 경우에는 리프 노드에 인덱스가 저장되어 있지만, 실제로 힙 영역에 저장된 위치는 각기 다르기 때문에
클러스터링 인덱스에 비해 상대적으로 불리하다.

### 인덱스를 설정하는 기준
1. 카디널리티(Cardinality)가 높은 컬럼
* 카디널리티란 컬럼에 사용되는 값의 다양성 정도를 말함.
* 한 컬럼이 갖고 있는 값의 중복도가 낮은 경우, 값들이 대부분 다른 값을 가짐.
* 카디널리티가 낮으면 인덱스 검색의 범위가 많아지므로, 인덱스 스캔에 불리하다.

2. 활용도가 높은 컬럼
* 해당 컬럼이 실제 작업에서 얼마나 활용되는가?
    * where절, join절, order by 절에 자주 활용되는지

3. 중복도가 낮은 컬럼
* 중복 인덱스 여부에 대한 값으로, 같은 컬럼에 대해 인덱스가 중복으로 생성되는 경우가 많다.

4. 데이터 변경(INSERT, UPDATE, DELETE)이 적게 발생하는 컬럼

5. 범위 검색이 적은 컬럼

6. 데이터가 많은 테이블
* 데이터가 적은 테이블은 인덱스 설정이 오히려 성능 저하를 일으킬 수도 있다.

7. 키의 크기가 작은 컬럼
* 키의 크기가 길 수록 페이지에 저장되는 인덱스 양이 줄고, 이에 따라 조회시 더 많은 페이지를 조회해야 한다.

결론적으로, 데이터의 변경이 잦은 컬럼은 피하고, 조회에 주로 사용되는 컬럼에 Index를 생성해서 사용하는 것이 유리하다.
++ 인덱스를 태우는 순서 역시 인덱스 성능에 영향을 미치게 된다.
++ 여러 컬럼으로 인덱스 구성 시, 카더널리티가 높은 순에서 낮은 순으로 지정하는 것이 좋다.

### 인덱스 사용 시 주의사항
* 복수 개의 칼럼으로 인덱스 구성시, 첫 번째 인덱스 칼럼은 조회조건에 포함되어야 한다.
* BETWEEN, LIKE, <, > 등 범위 조건에 사용된 컬럼은 인덱스 타는데, 그 뒤에 위치한 인덱스 컬럼들은 인덱스로 사용되지 않는다.

```sql
select *
from user
where group = 'premium'
and age > 18
and gender = 'M'
```
해당 쿼리에서 범위조건(age > 18) 이후에 위치한 gender는 인덱스를 타지 않는다.

* AND 연산은 ROW 수가 줄어들지만, OR연산은 비교 ROW가 늘어나므로, Full Table Scan으로 이어지기 쉽다.
* 인덱스로 사용된 컬럼은 컬럼 그대로 사용해야 인덱스를 사용할 수 있다.
    * number + 1 = 18 (x) / number = 18 - 1 (o)

* null도 where ? is null 형태로 인덱스를 사용 가능하다(MySQL)

### 커버링 인덱스
커버링 인덱스란, 쿼리를 충족시키는 데 필요한 모든 데이터를 갖고 있는 인덱스를 말한다.
쿼리를 충족시킨다는 것은, SELECT, WHERE, ORDER BY, LIMIT, GROUP BY 등에서 아용되는 모든 컬럼이 인덱스 컬럼 안에 포함되는 경우를 말한다.

```sql
SELECT id
FROM items
WHERE 조건문
ORDER BY id DESC 
OFFSET 페이지번호
LIMIT 페이지사이즈
```
-> 쿼리 내 모든 항목이 인덱스 컬럼으로만 이뤄지게 하여, 인덱스 내부에서 쿼리가 완성될 수 있도록 하는 방식

* 커버링 인덱스가 아니라면?
    * 인덱스 조건에 부합한 where 조건이 있더라도, select에 인덱스에 포함된 컬럼 외 다른 컬럼값이 필요한 경우 데이터 블록을 탐색해야 한다.
      -> 결국 커버링 인덱스란 실제 데이터에 접근 행위 없이 인덱스에 있는 컬럼값으로만 쿼리를 완성하는 것을 목표로 한다.

### 출처
* https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/
* https://yurimkoo.github.io/db/2020/03/14/db-index.html
* https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC
* https://jojoldu.tistory.com/243
* https://jojoldu.tistory.com/476
