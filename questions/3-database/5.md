# 인덱스를 설정하는 기준들에 대해 설명해주세요.

## 인덱스(Index)란?
* 인덱스란 DB테이블에 대한 검색 성능의 속도를 높여주는 자료구조이다. 
  * 기본적으로 인덱스가 없는 경우, Full Table Scan을 하게 되며, 탐색의 시간 복잡도는 O(n)이 소요된다.
* 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에
데이터의 물리적 주소와 함께 저장된다.
* 인덱스 생성 컬럼에 where 조건을 걸면 옵티마이저에서 판단하여 생성된 인덱스를 타고, 인덱스에
저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 방식으로 동작한다.
* 결과적으로 검색 속도의 향상을 가져올 수 있다.
  ![img](https://github.com/COW-edu/backend-cs-study/assets/59856002/2caac798-272d-4bb7-b9a5-77448fda0fbf)

## 인덱스(Index)의 자료 구조

### Hash Table
* key - value 형식으로 시간복잡도 O(1) time에 검색을 완료할 수 있다.
* where 조건의 = 연산에는 효율적이지만, 부등호 연산에는 부적합하다.
* 해시 충돌 문제가 발생할 수 있다.

### B-Tree
* 자식 노드가 2개 이상이며, 모든 리프노드들이 같은 레벨을 가질 수 있도록 하는 balanced-tree이다.
* 특정 컬럼의 key(값)에 대항하는 노드에 데이터의 위치(value)를 저장한다.
* BST처럼 왼쪽 자식은 항상 Key보다 작은 값을, 오른쪽 자식은 큰 값을 가진다.
* 이를 통해 범위 검색에서 해시 테이블보다 효율적인 탐색이 가능하다.
  * 평균 시간 복잡도는 O(logN)임을 보장.

### B+ Tree
* B Tree를 확장 및 개선한 자료 구조로서, 말단의 리프 노드에만 데이터의 위치를 관리한다.
* 중간 브랜치 노드에 Value가 없어서 B-Tree보다 메모리를 덜 차지하는 만큼, 노드의 메모리에 더 많은 Key를 저장하고, 결과적으로 Tree의 높이를 줄일 수 있다.

### 인덱스(Index)의 장점
* 인덱스의 가장 큰 특징은 데이터들이 정렬된다는 점이다.
  * 이는 조건 검색에서 굉장한 효율을 지니게 된다.(select절 성능 향상)
  * Order by가 불필요하며, MIN, MAX의 효율적인 처리가 가능하다.

### 인덱스(Index)의 단점
* 정렬된 상태를 계속 유지시켜야 한다는 점이다.
* 레코드 내에 데이터 수정이 잦을 경우 좋지 않다.(insert, update, delete 성능 저하)
  * INDEX 테이블, 원본 테이블 두 군데에 데이터 수정 작업이 모두 이루어져야 하기 때문이다.
  * 인덱스 관리를 위해 저장된 데이터의 약 10% 정도의 추가 데이터 공간이 필요하다.
  * 초기 index 생성 리소스가 소요됨.

## 인덱스(Index) 타입 종류

### 클러스터형 인덱스(Clustering index)(=PK 인덱스)
  * 처음부터 정렬이 되어있는 영어 사전과 같은 개념.
  * 데이터들을 일정 기준으로 정렬해주는 인덱스다.
  * 인덱스 생성 시 데이터 페이지 전체가 재정렬된다
  * PK 설정시, 자동으로 생성된다고 하여 PK 인덱스라고도 부름.
  * 한 테이블에 1개만 만들 수 있다
  * 클러스터 인덱스는 정보 공간을 적게 사용하면서 테이블 공간 자체를 활용

![img_1](https://github.com/COW-edu/backend-cs-study/assets/59856002/b1fb4ea8-f605-4bcc-a32c-b058d6228efa)
인덱싱을 하면 루트 페이지가 만들어진다. 이때 루트 페이지란 각 데이터 페이지의 첫 번째 데이터를 담고 있다.
데이터 페이지 자체를 인덱스 페이지로 삼는 것이다.

![img_3](https://github.com/COW-edu/backend-cs-study/assets/59856002/a589ba04-46c0-4805-b2ea-74023b22fcb3)
데이터 삽입 시, 1000번 페이지에 공간이 없어 페이지 분할이 일어난다.
이렇게 삽입, 삭제 시마다 페이지 분할이나 정렬이 필요하므로 성능이 나빠지게 된다.

### 보조 인덱스(Secondary index)
  * 논 클러스터 인덱스라고 불리며, 후보키에만 부여할 수 있는 인덱스다.
  * 데이터 페이지는 그냥 두고, 별도의 페이지에 인덱스를 구성한다.(데이터 페이지가 자동 정렬되지 않는다.)
  * 보조 인덱스의 리프 페이지는 데이터가 위치하는 주소값(RID)이다.
  * 보조 인덱스는 여러 개 생성할 수 있다.(데이터 페이지에 직접 변화를 주지 않기 때문이다.)
    ![img_2](https://github.com/COW-edu/backend-cs-study/assets/59856002/0f2506de-fc9a-439a-9a1b-96c7eb17980e)


![img_4](https://github.com/COW-edu/backend-cs-study/assets/59856002/e7244896-072f-41a5-9e2d-d594b8be0dd6)
데이터 조회 시, 거쳐야 하는 조회 DEPTH는 3이다.
이러한 차이는 데이터의 양이 많을수록 클러스터 인덱스에 비해 성능이 크게 뒤떨어진다.

![img_5](https://github.com/COW-edu/backend-cs-study/assets/59856002/1b4e15fc-51ef-451c-a07e-254b178a3796)
데이터 삽입 시, 페이지 빈곳에 데이터를 넣고 리프 페이지에서 매핑만 하면 되기 때문에, 페이지 분할이 일어나지 않는다.


 | 비교       |      클러스터 인덱스      |        보조 인덱스        |
|:---------|:------------------:|:--------------------:|
| 검색(조회)   |        빠르다         |         느리다          |
 | 입력/수정/삭제 |        느리다         |         빠르다          |
| 사용 메모리   |         적다         |          많다          |
| 인덱스      |    인덱스가 주요 데이터     |  인덱스가 데이터의 사본(Copy)  |
| 개수       |      테이블 당 1개      |      테이블에 여러 개       |
| 리프 노드    |   리프 노드 자체가 데이터    | 리프 노드는 데이터가 저장되는 위치  |
| 저장값      |  데이터 저장한 블록의 포인터   | 값과 데이터의 위치를 가리키는 포인터 |
| 정렬       | 인덱스 순서와 물리적 순서가 일치 | 인덱스 순서와 물리적 순서가 불일치  |

### 인덱스를 설정하는 기준
1. 카디널리티(Cardinality)가 높은 컬럼
* 카디널리티란 컬럼에 사용되는 값의 다양성 정도를 말함.
* 한 컬럼이 갖고 있는 값의 중복도가 낮은 경우, 값들이 대부분 다른 값을 가짐.
* 카디널리티가 낮으면 인덱스 검색의 범위가 많아지므로, 인덱스 스캔에 불리하다.

2. 활용도가 높은 컬럼
* 해당 컬럼이 실제 작업에서 얼마나 활용되는가?
  * where절, join절, order by 절에 자주 활용되는지

3. 중복도가 낮은 컬럼
* 중복 인덱스 여부에 대한 값으로, 같은 컬럼에 대해 인덱스가 중복으로 생성되는 경우가 많다.

4. 데이터 변경(INSERT, UPDATE, DELETE)이 적게 발생하는 컬럼

5. 범위 검색이 적은 컬럼

6. 데이터가 많은 테이블
* 데이터가 적은 테이블은 인덱스 설정이 오히려 성능 저하를 일으킬 수도 있다.

결론적으로, 데이터의 변경이 잦은 컬럼은 피하고, 조회에 주로 사용되는 컬럼에 Index를 생성해서 사용하는 것이 유리하다.

### 출처
* https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/
* https://yurimkoo.github.io/db/2020/03/14/db-index.html
* https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC